package com.game.fickapets;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.util.Hashtable;
import java.util.Vector;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;

import android.app.Activity;
import android.content.Context;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.http.AndroidHttpClient;
import android.os.AsyncTask;
import android.util.DisplayMetrics;
import android.widget.ImageView;

/*
 * Lots of this code borrowed from https://github.com/koush/UrlImageViewHelper
 */

public class UrlImageViewHandler {
	/* keep track of what url each view is waiting for since listView recycles views and the urls each view is waiting
	 * for can change frequently
	 */
	private static Hashtable<ImageView, String> pendingViews = new Hashtable<ImageView, String>();
	
	
	/* Values for in-memory cacheing of images */
	private static int bytesInMemory;
	private static Hashtable<String, BitmapDrawable> downloadedImages = new Hashtable<String, BitmapDrawable>();
	private static Vector<CacheEntry> downloadedImageQueue = new Vector<CacheEntry>();
	private static final int MAX_BYTES_IN_MEMORY = 4096;
	
	/* Values for file system cacheing of images */
	private static int bytesOnDisk;
	private static Vector<CacheEntry> files = new Vector<CacheEntry>();
	private static final int MAX_BYTES_ON_DISK = 10000000;
	
	private static Resources mResources;
	private static DisplayMetrics mMetrics;
	private static Context context;
	
	
	public static void setUrlDrawable(final ImageView imageView, final String url, final int defaultResource) {
		if (url == null || url.equals("") || imageView == null) {
			return;
		}
		if (context == null) context = imageView.getContext();
		if (downloadedImages.containsKey(url)) {
			imageView.setImageDrawable(downloadedImages.get(url));
			return;
		}
		pendingViews.put(imageView, url);
		final Drawable defaultDrawable = imageView.getResources().getDrawable(defaultResource);
		//final String imageFilename = getFilenameForUrl(url);
		imageView.setImageDrawable(defaultDrawable);
		AsyncTask<Void, Void, Bitmap> imageDownloader = new AsyncTask<Void, Void, Bitmap>() {
			@Override
			protected Bitmap doInBackground(Void...params) {
				Context context = imageView.getContext();
				AndroidHttpClient client = AndroidHttpClient.newInstance(context.getPackageName());
				try {
					HttpGet get = new HttpGet(url);
					final HttpParams httpParams = new BasicHttpParams();
					HttpClientParams.setRedirecting(httpParams, true);
					get.setParams(httpParams);
					System.out.println("Requesting this URL: " + get.getURI());
					HttpResponse response = client.execute(get);
					int status = response.getStatusLine().getStatusCode();
					if (status != HttpURLConnection.HTTP_OK) {
						return null;
					}
					HttpEntity entity = response.getEntity();
					InputStream is = entity.getContent();
					prepareResources(context);
					final Bitmap bitmap = BitmapFactory.decodeStream(is);
					return bitmap;
				} catch (Exception ex) {
					ex.printStackTrace();
					return null;
				} finally {
					client.close();
				}
			}
			
			private int getBytesInBitmap(Bitmap bitmap) {
				return bitmap.getRowBytes() * bitmap.getHeight();
			}
			

			
			@Override
			protected void onPostExecute(Bitmap bitmap) {
				final int bytes = getBytesInBitmap(bitmap);
				BitmapDrawable result = new BitmapDrawable(mResources, bitmap);
				if (result != null) {
					cacheImage(result, url, bytes);
					String pendingUrl = pendingViews.get(imageView);
					if (pendingUrl == null) return;
					BitmapDrawable imageToUse = downloadedImages.get(pendingUrl);
					pendingViews.remove(imageView);
					if (imageToUse == null) return;
					imageView.setImageDrawable(imageToUse);
				}
			}
		};
		imageDownloader.execute();
	}
	
	private static void moveToFileSystem (CacheEntry entry, final BitmapDrawable image) {
		final String filename = getFilenameForUrl(entry.name);
		File file = context.getFileStreamPath(filename);
		if (!file.exists()) {
			final CacheEntry fileEntry = new CacheEntry(filename, entry.bytes);
			
			files.add(fileEntry);
			bytesOnDisk += fileEntry.bytes;
			while (bytesOnDisk > MAX_BYTES_ON_DISK) {
				CacheEntry entryToRemove = files.remove(0);
				final File fileToRemove = context.getFileStreamPath(entryToRemove.name);
				if (fileToRemove.exists()) {
					new Thread(new Runnable() {
						public void run() {
							try {
								fileToRemove.delete();
							} catch(Exception ex) {}
						}
					});
				}
				bytesOnDisk -= entryToRemove.bytes;
			}
			
			new Thread(new Runnable() {
				public void run() {
					try {
						FileOutputStream fos = context.openFileOutput(fileEntry.name, Context.MODE_PRIVATE);
						image.getBitmap().compress(Bitmap.CompressFormat.PNG, 100, fos);
						saveCacheState();
					} catch(IOException ex) {}
				}
			});
		}
	}
	
	private synchronized static void saveCacheState() {
		
	}
	
	private static void cacheImage(BitmapDrawable image, String url, int bytes) {
		downloadedImages.put(url, image);
		CacheEntry entry = new CacheEntry(url, bytes);
		downloadedImageQueue.add(entry);
		bytesInMemory += bytes;
		while (bytesInMemory > MAX_BYTES_IN_MEMORY) {
			CacheEntry removedEntry = downloadedImageQueue.remove(0);
			moveToFileSystem (removedEntry, downloadedImages.remove(removedEntry.name));
			bytesInMemory -= removedEntry.bytes;
		}
	}
	
	/* not sure what this does - just took it from the code I based this class on */
	private static void prepareResources(Context context) {
		if (mMetrics != null) {
			return;
		}
		mMetrics = new DisplayMetrics();
		
		((Activity)context).getWindowManager().getDefaultDisplay().getMetrics(mMetrics);
		AssetManager manager = context.getAssets();
		mResources = new Resources(manager, mMetrics, context.getResources().getConfiguration());
	}
	
	private static String getFilenameForUrl(final String url) {
		return "" + url.hashCode() + ".urlImage";
	}
	
	public static class CacheEntry {
		String name;
		int bytes;
		public CacheEntry(String name, int bytes) {
			this.name = name;
			this.bytes = bytes;
		}
;
	}
}
